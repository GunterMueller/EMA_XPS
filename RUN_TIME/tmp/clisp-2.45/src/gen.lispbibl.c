#line 1 "lispbibl.d"





















































































































































































































































































































#ifdef WIN32_NATIVE
  puts("#define WIN32_NATIVE");
#endif
#ifdef UNIX
  puts("#define UNIX");
#endif













































































































































































































export_def(BIG_ENDIAN_P);












































































































































































































































































































































#ifdef HAVE_SAVED_REGISTERS
  puts("#ifndef IN_MODULE_CC");
  #ifdef STACK_register
    printf("register long STACK_reg __asm__(\"%s\");\n",STACK_register);
  #endif
  #ifdef mv_count_register
    printf("register long mv_count_reg __asm__(\"%s\");\n",mv_count_register);
  #endif
  #ifdef value1_register
    printf("register long value1_reg __asm__(\"%s\");\n",value1_register);
  #endif
  #ifdef back_trace_register
    printf("register long back_trace_reg __asm__(\"%s\");\n",back_trace_register);
  #endif
  printf("struct registers { ");
  #ifdef STACK_register
    printf("long STACK_register_contents; ");
  #endif
  #ifdef mv_count_register
    printf("long mv_count_register_contents; ");
  #endif
  #ifdef value1_register
    printf("long value1_register_contents; ");
  #endif
  #ifdef back_trace_register
    printf("long back_trace_register_contents; ");
  #endif
  puts("};");
  puts("extern struct registers * callback_saved_registers;");
  puts("#endif");
#endif



export_def(VALUES_IF(C));



export_def(VALUES0);



export_def(VALUES1(A));



export_def(VALUES2(A,B));



export_def(VALUES3(A,B,C));





















puts("#if !defined(__GNUC__) && !defined(inline)");
puts("#define inline");
puts("#endif");









export_def(BEGIN_DECLS);
export_def(END_DECLS);





























puts("#define CONCAT_(xxx,yyy)  xxx##yyy");
puts("#define CONCAT3_(aaa,bbb,ccc)  aaa##bbb##ccc");
#if notused
puts("#define CONCAT4_(aaa,bbb,ccc,ddd)  aaa##bbb##ccc##ddd");
puts("#define CONCAT5_(aaa,bbb,ccc,ddd,eee)  aaa##bbb##ccc##ddd##eee");
#endif
puts("#define CONCAT(xxx,yyy)  CONCAT_(xxx,yyy)");
puts("#define CONCAT3(aaa,bbb,ccc)  CONCAT3_(aaa,bbb,ccc)");
#if notused
puts("#define CONCAT4(aaa,bbb,ccc,ddd)  CONCAT4_(aaa,bbb,ccc,ddd)");
puts("#define CONCAT5(aaa,bbb,ccc,ddd,eee)  CONCAT5_(aaa,bbb,ccc,ddd,eee)");
#endif











puts("#define STRING(token) #token");
puts("#define STRINGIFY(token) STRING(token)");















































export_def(nonreturning_function(storclass,funname,arguments));




























puts("#define NOTREACHED  error_notreached(__FILE__,__LINE__)");



 puts("#define ASSERT(expr)  do { if (!(expr)) NOTREACHED; } while(0)");























#ifdef GNU
  emit_define("alloca","__builtin_alloca");
#elif defined(MICROSOFT)
  puts("#include <malloc.h>");
  emit_define("alloca","_alloca");
#elif defined(HAVE_ALLOCA_H)
  puts("#include <alloca.h>");
  #ifndef alloca
    #if !(defined(UNIX_OSF) || defined(UNIX_DEC_ULTRIX))
      puts("extern void* alloca (int size);");
    #endif
  #endif
#elif defined(_AIX)
  puts("#pragma alloca");
#elif !defined(NO_ALLOCA)
  puts("extern void* alloca (int size);");
#endif













#if defined(HAVE_LONG_LONG_INT)
  puts("#define LL(nnnn) nnnn##LL");
  puts("#define ULL(nnnn) nnnn##ULL");
#elif defined(MICROSOFT)
  puts("#define LL(nnnn) nnnn##i64");
  puts("#define ULL(nnnn) nnnn##ui64");
#endif

























































#ifdef __CHAR_UNSIGNED__
  emit_typedef("signed char","SBYTE");
#else
  emit_typedef("char","SBYTE");
#endif
emit_typedef("unsigned char","UBYTE");
emit_typedef("short","SWORD");
emit_typedef("unsigned short","UWORD");
#if (long_bitsize==32)
  emit_typedef("long","SLONG");
  emit_typedef("unsigned long","ULONG");
#elif (int_bitsize==32)
  emit_typedef("int","SLONG");
  emit_typedef("unsigned int","ULONG");
#endif
#if (long_bitsize==64)
  emit_typedef("long","SLONGLONG");
  emit_typedef("unsigned long","ULONGLONG");
#elif defined(MICROSOFT)
  emit_typedef("__int64","SLONGLONG");
  emit_typedef("unsigned __int64","ULONGLONG");
#elif defined(HAVE_LONG_LONG_INT)
  emit_typedef("long long","SLONGLONG");
  emit_typedef("unsigned long long","ULONGLONG");
#endif


#ifdef HAVE_STDBOOL_H
  puts("#include <stdbool.h>");
#else
  print_file("stdbool.h");
#endif
















puts("#undef NULL");
export_def(NULL);

















































export_def(unspecified);












export_def(pointerplus(pointer,offset));






































export_def(bit(n));
#if notused
export_def(bitm(n));
#endif
export_def(bit_test(x,n));
export_def(minus_bit(n));
#if notused
export_def(minus_bitm(n));
#endif




/* FIXME: Difference between lispbibl.d and clisp.h */
puts("#define ifloor(a_from_floor,b_from_floor)  ((a_from_floor) / (b_from_floor))");





export_def(ceiling(a_from_ceiling,b_from_ceiling));





/* FIXME: Difference between lispbibl.d and clisp.h */
puts("#define round_down(a_from_round,b_from_round)  (ifloor(a_from_round,b_from_round)*(b_from_round))");





export_def(round_up(a_from_round,b_from_round));




































































export_def(DYNAMIC_ARRAY(arrayvar,arrayeltype,arraysize));
export_def(FREE_DYNAMIC_ARRAY(arrayvar));
















































































{ int i;
  for (i=1; i<=8; i++) {
    sprintf(buf,"uint%d",i); emit_typedef("UBYTE",buf);
    sprintf(buf,"sint%d",i); emit_typedef("SBYTE",buf);
  }
  for (i=9; i<=16; i++) {
    sprintf(buf,"uint%d",i); emit_typedef("UWORD",buf);
    sprintf(buf,"sint%d",i); emit_typedef("SWORD",buf);
  }
  for (i=17; i<=32; i++) {
    sprintf(buf,"uint%d",i); emit_typedef("ULONG",buf);
    sprintf(buf,"sint%d",i); emit_typedef("SLONG",buf);
  }
  #ifdef HAVE_LONG_LONG_INT
    for (i=33; i<=64; i++)
      if ((i==33) || (i==48) || (i==64)) {
        sprintf(buf,"uint%d",i); emit_typedef("ULONGLONG",buf);
        sprintf(buf,"sint%d",i); emit_typedef("SLONGLONG",buf);
      }
  #endif
}


























sprintf(buf,"sint%d",intBsize); emit_typedef(buf,"sintB");
sprintf(buf,"uint%d",intBsize); emit_typedef(buf,"uintB");
#if notused
sprintf(buf,"sint%d",intWsize); emit_typedef(buf,"sintW");
#endif
sprintf(buf,"uint%d",intWsize); emit_typedef(buf,"uintW");
sprintf(buf,"sint%d",intLsize); emit_typedef(buf,"sintL");
sprintf(buf,"uint%d",intLsize); emit_typedef(buf,"uintL");
#if notused
#ifdef intQsize
  sprintf(buf,"sint%d",intQsize); emit_typedef(buf,"sintQ");
  sprintf(buf,"uint%d",intQsize); emit_typedef(buf,"uintQ");
#else
  emit_typedef("struct { sintL hi; uintL lo; }","sintL2");
  emit_typedef("struct { uintL hi; uintL lo; }","uintL2");
#endif
#endif





sprintf(buf,"sint%d",pointer_bitsize); emit_typedef(buf,"sintP");
sprintf(buf,"uint%d",pointer_bitsize); emit_typedef(buf,"uintP");











































#if notused
sprintf(buf,"sint%d",intBWsize); emit_typedef(buf,"sintBW");
sprintf(buf,"uint%d",intBWsize); emit_typedef(buf,"uintBW");
sprintf(buf,"sint%d",intWLsize); emit_typedef(buf,"sintWL");
#endif
sprintf(buf,"uint%d",intWLsize); emit_typedef(buf,"uintWL");
#if notused
sprintf(buf,"sint%d",intBWLsize); emit_typedef(buf,"sintBWL");
#endif
sprintf(buf,"uint%d",intBWLsize); emit_typedef(buf,"uintBWL");

































































































































































export_def(uintC);
#if notused
export_def(sintC);
#endif
























#if notused
sprintf(buf,"sint%d",intDsize); emit_typedef(buf,"sintD");
#endif
sprintf(buf,"uint%d",intDsize); emit_typedef(buf,"uintD");




























#if notused
#ifdef WIDE_HARD
  puts("#define WIDE_HARD");
#endif
#ifdef WIDE_SOFT
  puts("#define WIDE_SOFT");
#endif
#ifdef WIDE_AUXI
  puts("#define WIDE_AUXI");
#endif
#ifdef WIDE
  puts("#define WIDE");
#endif
#endif

























#ifdef HEAPCODES
  puts("#define HEAPCODES");
#endif















































printf("typedef enum { persev_full=%d, persev_partial=%d, persev_immediate=%d, persev_bonus=%d } perseverance_t;\n",persev_full,persev_partial,persev_immediate,persev_bonus);









puts("#include <stdlib.h>");
puts("#include <sys/types.h>");
#if defined(UNIX)
  emit_typedef("int","Handle");
  emit_typedef("int","SOCKET");
  #ifdef UNIX_CYGWIN32
    puts("#include <windows.h>");
    puts("#undef WIN32");
    puts("extern long time_t_from_filetime (const FILETIME * ptr);");
    puts("extern void time_t_to_filetime (time_t time_in, FILETIME * out);");
  #endif
#elif defined(WIN32_NATIVE)
  puts("#include <windows.h>");
  export_def(Handle);
  puts("#include <winsock2.h>"); /* defines SOCKET */
#else
  puts("#error what is Handle on your platform?!");
#endif
#if defined(UNIX)
  puts("extern ssize_t fd_read (int fd, void* buf, size_t nbyte, perseverance_t persev);");
  puts("extern ssize_t fd_write (int fd, const void* buf, size_t nbyte, perseverance_t persev);");
#elif defined(WIN32_NATIVE)
  puts("extern ssize_t fd_read (Handle fd, void* buf, size_t nbyte, perseverance_t persev);");
  puts("extern ssize_t fd_write (Handle fd, const void* buf, size_t nbyte, perseverance_t persev);");
#endif



































export_def(unused);





































puts("nonreturning_function(extern, OS_error, (void));");



































































































































































































#ifdef HAVE_SIGNALS
  puts("#define HAVE_SIGNALS");
#endif














































#ifdef FOREIGN
  export_def(FOREIGN);
#endif































































































































































#if (defined(WIDE_AUXI) || defined(OBJECT_STRUCT) || defined(WIDE_STRUCT)) && defined(WIDE) && !defined(WIDE_HARD) && defined(GENERATIONAL_GC)
  #define attribute_aligned_object " __attribute__ ((aligned(8)))"
#else
  #define attribute_aligned_object ""
#endif





































































#if !defined(WIDE_SOFT)
  #if defined(WIDE_AUXI)
    strcpy(buf,"struct { union { struct { ");
    #if BIG_ENDIAN_P
      strcat(buf,"uintP auxi_ob; uintP one_ob;");
    #else
      strcat(buf,"uintP one_ob; uintP auxi_ob;");
    #endif
    strcat(buf," } both; oint align_o");
    strcat(buf,attribute_aligned_object);
    strcat(buf,"; } u");
    strcat(buf,attribute_aligned_object);
    strcat(buf,"; }");
    emit_typedef(buf,"gcv_object_t");
    emit_define("one_o","u.both.one_ob");
    emit_define("auxi_o","u.both.auxi_ob");
  #elif defined(OBJECT_STRUCT)
    #ifdef DEBUG_GCSAFETY
      puts("struct object { uintP one_o; uintL allocstamp; };");
      puts("struct gcv_object_t { uintP one_o; operator object () const; gcv_object_t (object obj); gcv_object_t (struct fake_gcv_object obj); gcv_object_t (); };");
    #else
      emit_typedef("struct { uintP one_o; }","gcv_object_t");
    #endif
  #else
    emit_typedef("void *","gcv_object_t");
  #endif
  #ifdef WIDE_AUXI
    emit_typedef("uint64","oint");
    emit_typedef("sint64","soint");
  #else
    emit_typedef("uintP","oint");
    emit_typedef("sintP","soint");
  #endif
#else
  emit_typedef("uint64","oint");
  emit_typedef("sint64","soint");
  #ifdef WIDE_STRUCT
    strcpy(buf,"struct { union {\n");
    #if BIG_ENDIAN_P==WIDE_ENDIANNESS
      strcat(buf,"  struct { /*tint*/ uintL type; /*aint*/ uintL addr; } both;\n");
    #else
      strcat(buf,"  struct { /*aint*/ uintL addr; /*tint*/ uintL type; } both;\n");
    #endif
    strcat(buf,"  oint one_u");
    strcat(buf,attribute_aligned_object);
    strcat(buf,"; } u");
    strcat(buf,attribute_aligned_object);
    strcat(buf,"; }");
    emit_typedef(buf,"gcv_object_t");
    emit_define("one_o","u.one_u");
  #else
    emit_typedef("oint","gcv_object_t");
  #endif
#endif

























export_def(as_oint(expr));
export_def(as_object(o));




















































































































































































































































































#if notused
 export_def(oint_type_shift);
 export_def(oint_type_len);
 export_def(oint_type_mask);
 export_def(oint_addr_shift);
 export_def(oint_addr_len);
 export_def(oint_addr_mask);
#endif













#if notused
 export_def(oint_data_shift);
 export_def(oint_data_len);
 export_def(oint_data_mask);
#endif



sprintf(buf,"uint%d",oint_type_len); emit_typedef(buf,"tint");




sprintf(buf,"uint%d",oint_addr_len); emit_typedef(buf,"aint");
#if notused
sprintf(buf,"sint%d",oint_addr_len); emit_typedef(buf,"saint");
#endif










sprintf(buf,"uint%d",intVsize); emit_typedef(buf,"uintV");
sprintf(buf,"sint%d",intVsize); emit_typedef(buf,"sintV");
























#if notused
 export_def(addr_shift);
#endif





































































































































#ifdef DEBUG_GCSAFETY
  puts("extern uintL alloccount;");
#else
  emit_typedef("gcv_object_t","object");
#endif





































#if notused
export_def(tint_type_mask);
#endif












#if !(defined(WIDE_SOFT) || defined(WIDE_AUXI) || defined(OBJECT_STRUCT))
  emit_define("objectplus(obj,offset)","((object)pointerplus(obj,offset))");
#elif defined(WIDE_AUXI)
  puts("static inline object objectplus (object obj, saint offset) { return (object){u:{both:{ one_ob: obj.one_o+offset, auxi_ob: obj.auxi_o }}}; }");
#else
  emit_define("objectplus(obj,offset)","as_object(as_oint(obj)+(soint)(offset))");
#endif














#if notused
 export_def(vbit(n));
 export_def(vbitm(n));
 export_def(vbit_test(x,n));
 export_def(minus_vbit(n));
#endif














export_def(wbit);
#if notused
 export_def(wbitm);
#endif
export_def(wbit_test);
export_def(minus_wbit);







































































































































































































































































































































































#ifdef TYPECODES
 export_def(typecode(expr));
 export_def(mtypecode(expr));
 export_def(type_untype_object(type,address));
 export_def(upointer(obj));
 export_def(type_pointer_object(type,address));
 export_def(type_constpointer_object(type,address));
#else
 export_def(number_immediatep(obj));
 export_def(immediate_object_p(obj));
 export_def(gcinvariant_object_p(obj));
 export_def(gcinvariant_oint_p(obj_o));
 export_def(gcinvariant_bias_p(bias));
#endif
export_def(type_data_object(type,address));
export_def(type_zero_oint(obj));










export_def(varobjects_misaligned);
export_def(VAROBJECTS_ALIGNMENT_DUMMY_DECL);












































export_def(varobject_alignment);














































































































































































































































































































#ifdef TYPECODES
 export_def(gcinvariant_type_p(type));
 export_def(gcinvariant_type_sum(type));
 export_def(gcinvariant_type_aux(type));
 export_def(gcinvariant_object_p(obj));
 export_def(gcinvariant_oint_p(obj_o));
#endif




























#if notused
export_def(addressbus_mask);
#endif

















































































#ifdef TYPECODES
 export_def(pointable_unchecked(obj));
 export_def(pointable_address_unchecked(obj_o));
 #ifdef DEBUG_GCSAFETY
  puts("static inline void* pointable (gcv_object_t obj) { return pointable_unchecked(obj); }");
  puts("static inline void* pointable (object obj) { return pointable_unchecked((gcv_object_t)obj); }");
 #else
  emit_define("pointable(obj)","pointable_unchecked(obj)");
 #endif
#endif

























































puts("extern bool inside_gc;");

































































#ifdef DEBUG_GCSAFETY
  puts("static inline bool gcinvariant_symbol_p (object obj);");
  #ifdef LINUX_NOEXEC_HEAPCODES
    puts("static inline bool nonimmsubrp (object obj);");
  #else
    emit_define("nonimmsubrp(obj)","false");
  #endif
  export_def(nonimmprobe(obj_o));
  puts("inline gcv_object_t::operator object () const { nonimmprobe(one_o); return (object){ one_o: one_o, allocstamp: alloccount }; }");
  puts("inline gcv_object_t::gcv_object_t (object obj) { if (!(gcinvariant_object_p(obj) || gcinvariant_symbol_p(obj) || obj.allocstamp == alloccount || nonimmsubrp(obj))) abort(); one_o = as_oint(obj); nonimmprobe(one_o); }");
  puts("inline gcv_object_t::gcv_object_t () {}");
#endif











































































































































































































































































#if (oint_type_len<=8) && !defined(ARM) && !defined(DECALPHA) && !defined(IA64) && !defined(DEBUG_GCSAFETY)
  emit_typedef("uintB","hfint");
#else
  emit_typedef("uintP","hfint");
#endif






































































export_def(VAROBJECT_HEADER);
#ifndef TYPECODES
 export_def(GCself);
 export_def(varobject_type(ptr));
#endif


























































export_def(RECORD_HEADER);
sprintf(buf,"struct { RECORD_HEADER gcv_object_t recdata[unspecified]%s; }",attribute_aligned_object);
emit_typedef(buf,"record_");
emit_typedef("record_ *","Record");
export_def(record_type(ptr));
export_def(Record_type(obj));
export_def(record_flags(ptr));
export_def(record_flags_set(ptr,bits));
export_def(Record_flags(obj));


















export_def(VRECORD_HEADER);
emit_typedef("struct { VRECORD_HEADER }","vrecord_");
emit_typedef("vrecord_ *","Vrecord");
export_def(vrecord_length(ptr));


















































export_def(SRECORD_HEADER);
sprintf(buf,"struct { SRECORD_HEADER gcv_object_t recdata[unspecified]%s; }",attribute_aligned_object);
emit_typedef(buf,"srecord_");
emit_typedef("srecord_ *","Srecord");
export_def(srecord_length(ptr));



























export_def(XRECORD_HEADER);
#if notused
sprintf(buf,"struct { XRECORD_HEADER gcv_object_t recdata[unspecified]%s; }",attribute_aligned_object);
emit_typedef(buf,"xrecord_");
emit_typedef("xrecord_ *","Xrecord");
#endif





printf("#define Rectype_Closure %d\n",Rectype_Closure);

printf("#define Rectype_Structure %d\n",Rectype_Structure);

printf("#define Rectype_Instance %d\n",Rectype_Instance);


printf("#define Rectype_Hashtable %d\n",Rectype_Hashtable);

#ifndef TYPECODES


printf("#define Rectype_vector %d\n",Rectype_vector);

printf("#define Rectype_bvector %d\n",Rectype_bvector);

printf("#define Rectype_b2vector %d\n",Rectype_b2vector);

printf("#define Rectype_b4vector %d\n",Rectype_b4vector);

printf("#define Rectype_b8vector %d\n",Rectype_b8vector);

printf("#define Rectype_b16vector %d\n",Rectype_b16vector);

printf("#define Rectype_b32vector %d\n",Rectype_b32vector);



printf("#define Rectype_Svector %d\n",Rectype_Svector);

printf("#define Rectype_Sbvector %d\n",Rectype_Sbvector);

printf("#define Rectype_Sb2vector %d\n",Rectype_Sb2vector);

printf("#define Rectype_Sb4vector %d\n",Rectype_Sb4vector);

printf("#define Rectype_Sb8vector %d\n",Rectype_Sb8vector);

printf("#define Rectype_Sb16vector %d\n",Rectype_Sb16vector);

printf("#define Rectype_Sb32vector %d\n",Rectype_Sb32vector);



printf("#define Rectype_S8string %d\n",Rectype_S8string);

printf("#define Rectype_Imm_S8string %d\n",Rectype_Imm_S8string);

printf("#define Rectype_S16string %d\n",Rectype_S16string);

printf("#define Rectype_Imm_S16string %d\n",Rectype_Imm_S16string);

printf("#define Rectype_S32string %d\n",Rectype_S32string);

printf("#define Rectype_Imm_S32string %d\n",Rectype_Imm_S32string);

printf("#define Rectype_reallocstring %d\n",Rectype_reallocstring);


printf("#define Rectype_string %d\n",Rectype_string);


printf("#define Rectype_mdarray %d\n",Rectype_mdarray);



printf("#define Rectype_Bignum %d\n",Rectype_Bignum);

printf("#define Rectype_Lfloat %d\n",Rectype_Lfloat);

printf("#define Rectype_Dfloat %d\n",Rectype_Dfloat);

printf("#define Rectype_Ffloat %d\n",Rectype_Ffloat);
#endif


#ifdef SPVW_MIXED

printf("#define Rectype_Ratio %d\n",Rectype_Ratio);

printf("#define Rectype_Complex %d\n",Rectype_Complex);
#endif



#ifndef TYPECODES

printf("#define Rectype_Symbol %d\n",Rectype_Symbol);
#endif


printf("#define Rectype_Package %d\n",Rectype_Package);

printf("#define Rectype_Readtable %d\n",Rectype_Readtable);

printf("#define Rectype_Pathname %d\n",Rectype_Pathname);

#ifdef LOGICAL_PATHNAMES

printf("#define Rectype_Logpathname %d\n",Rectype_Logpathname);
#endif


printf("#define Rectype_Random_State %d\n",Rectype_Random_State);

#ifndef case_stream

printf("#define Rectype_Stream %d\n",Rectype_Stream);
#endif


printf("#define Rectype_Byte %d\n",Rectype_Byte);

printf("#define Rectype_Subr %d\n",Rectype_Subr);

printf("#define Rectype_Fsubr %d\n",Rectype_Fsubr);

printf("#define Rectype_Loadtimeeval %d\n",Rectype_Loadtimeeval);

printf("#define Rectype_Symbolmacro %d\n",Rectype_Symbolmacro);

printf("#define Rectype_GlobalSymbolmacro %d\n",Rectype_GlobalSymbolmacro);

printf("#define Rectype_Macro %d\n",Rectype_Macro);

printf("#define Rectype_FunctionMacro %d\n",Rectype_FunctionMacro);

printf("#define Rectype_BigReadLabel %d\n",Rectype_BigReadLabel);

printf("#define Rectype_Encoding %d\n",Rectype_Encoding);

printf("#define Rectype_Fpointer %d\n",Rectype_Fpointer);

#ifdef DYNAMIC_FFI

printf("#define Rectype_Faddress %d\n",Rectype_Faddress);

printf("#define Rectype_Fvariable %d\n",Rectype_Fvariable);

printf("#define Rectype_Ffunction %d\n",Rectype_Ffunction);
#endif


printf("#define Rectype_Weakpointer %d\n",Rectype_Weakpointer);

printf("#define Rectype_MutableWeakList %d\n",Rectype_MutableWeakList);

printf("#define Rectype_MutableWeakAlist %d\n",Rectype_MutableWeakAlist);

printf("#define Rectype_Weakmapping %d\n",Rectype_Weakmapping);

printf("#define Rectype_Finalizer %d\n",Rectype_Finalizer);

#ifdef SOCKET_STREAMS

printf("#define Rectype_Socket_Server %d\n",Rectype_Socket_Server);
#endif


#ifdef YET_ANOTHER_RECORD

printf("#define Rectype_Yetanother %d\n",Rectype_Yetanother);
#endif



printf("#define Rectype_WeakList %d\n",Rectype_WeakList);

printf("#define Rectype_WeakAnd %d\n",Rectype_WeakAnd);

printf("#define Rectype_WeakOr %d\n",Rectype_WeakOr);

printf("#define Rectype_WeakAndMapping %d\n",Rectype_WeakAndMapping);

printf("#define Rectype_WeakOrMapping %d\n",Rectype_WeakOrMapping);

printf("#define Rectype_WeakAlist_Key %d\n",Rectype_WeakAlist_Key);

printf("#define Rectype_WeakAlist_Value %d\n",Rectype_WeakAlist_Value);

printf("#define Rectype_WeakAlist_Either %d\n",Rectype_WeakAlist_Either);

printf("#define Rectype_WeakAlist_Both %d\n",Rectype_WeakAlist_Both);

printf("#define Rectype_WeakHashedAlist_Key %d\n",Rectype_WeakHashedAlist_Key);

printf("#define Rectype_WeakHashedAlist_Value %d\n",Rectype_WeakHashedAlist_Value);

printf("#define Rectype_WeakHashedAlist_Either %d\n",Rectype_WeakHashedAlist_Either);

printf("#define Rectype_WeakHashedAlist_Both %d\n",Rectype_WeakHashedAlist_Both);

#ifdef MULTITHREAD

 printf("#define Rectype_Thread %d\n",Rectype_Thread);

 printf("#define Rectype_Mutex %d\n",Rectype_Mutex);

 printf("#define Rectype_Exemption %d\n",Rectype_Exemption);
#endif












sprintf(buf,"struct { gcv_object_t cdr%s; gcv_object_t car%s; }",attribute_aligned_object,attribute_aligned_object);
emit_typedef(buf,"cons_");
emit_typedef("cons_ *","Cons");










#if notused
#ifdef SPVW_MIXED
  sprintf(buf,"struct { XRECORD_HEADER gcv_object_t rt_num%s; gcv_object_t rt_den%s; }",attribute_aligned_object,attribute_aligned_object);
#else
  sprintf(buf,"struct { gcv_object_t rt_num%s; gcv_object_t rt_den%s; }",attribute_aligned_object,attribute_aligned_object);
#endif
emit_typedef(buf,"ratio_");
emit_typedef("ratio_ *","Ratio");
#endif










#if notused
#ifdef SPVW_MIXED
  sprintf(buf,"struct { XRECORD_HEADER gcv_object_t c_real%s; gcv_object_t c_imag%s; }",attribute_aligned_object,attribute_aligned_object);
#else
  sprintf(buf,"struct { gcv_object_t c_real%s; gcv_object_t c_imag%s; }",attribute_aligned_object,attribute_aligned_object);
#endif
emit_typedef(buf,"complex_");
emit_typedef("complex_ *","Complex");
#endif























#if defined(LINUX_NOEXEC_HEAPCODES) && 0
  sprintf(buf,"struct { VAROBJECT_HEADER gcv_object_t symvalue%s; gcv_object_t symfunction%s; gcv_object_t hashcode%s; gcv_object_t proplist%s; gcv_object_t pname%s; gcv_object_t homepackage%s; gcv_object_t filler%s; }",attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object);
#else
  sprintf(buf,"struct { VAROBJECT_HEADER gcv_object_t symvalue%s; gcv_object_t symfunction%s; gcv_object_t hashcode%s; gcv_object_t proplist%s; gcv_object_t pname%s; gcv_object_t homepackage%s; }",attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object);
#endif
emit_typedef(buf,"symbol_");
emit_typedef("symbol_ *","Symbol");




















































































































sprintf(buf,"uint%d",char_int_len); emit_typedef(buf,"cint");
export_def(int_char(int_from_int_char));
export_def(char_int(char_from_char_int));







































#ifdef CHART_STRUCT
  emit_typedef("struct { cint one_c; }","chart");
#else
  emit_typedef("cint","chart");
#endif
export_def(as_cint(ch));
export_def(as_chart(c));
export_def(code_char(ch));
export_def(char_code(obj));



































#ifdef HAVE_SMALL_SSTRING
  emit_typedef("uint8","cint8");
  emit_typedef("uint16","cint16");
  emit_typedef("uint32","cint32");
#endif
















export_def(fixnum(x));






export_def(Fixnum_0);
export_def(Fixnum_1);
export_def(Fixnum_minus1);












export_def(posfixnum_to_V(obj));





#if notused
export_def(negfixnum_to_V(obj));
#endif
































export_def(fixnum_to_V(obj));
























export_def(fixnum_inc(obj,delta));



export_def(posfixnum(x));




export_def(negfixnum(x));




export_def(sfixnum(x));



































#ifdef TYPECODES
  emit_typedef("struct { VAROBJECT_HEADER uintC length; uintD data[unspecified]; }","bignum_");
#else
  emit_typedef("struct { VAROBJECT_HEADER uintD data[unspecified]; }","bignum_");
#endif
emit_typedef("bignum_ *","Bignum");
export_def(bignum_length(ptr));
export_def(Bignum_length(obj));




















emit_typedef("uint32","ffloat");
emit_typedef("union { ffloat eksplicit; }","ffloatjanus");


























#ifdef intQsize
  emit_typedef("uint64","dfloat");
#else
  #if BIG_ENDIAN_P
    emit_typedef("struct {uint32 semhi,mlo;}","dfloat");
  #else
    emit_typedef("struct {uint32 mlo,semhi;}","dfloat");
  #endif
#endif
emit_typedef("union { dfloat eksplicit; }","dfloatjanus");





























#if notused
emit_typedef("struct { VRECORD_HEADER }","sarray_");
emit_typedef("sarray_ *","Sarray");
#endif
export_def(sarray_length(ptr));
export_def(Sarray_length(obj));









emit_typedef("struct { VRECORD_HEADER uint8  data[unspecified]; }","sbvector_");
emit_typedef("sbvector_ *","Sbvector");
export_def(sbvector_length(ptr));
export_def(Sbvector_length(obj));






















































































































export_def(SSTRING_HEADER);
emit_typedef("struct { SSTRING_HEADER }","sstring_");
emit_typedef("sstring_ *","Sstring");
#ifdef HAVE_SMALL_SSTRING
  export_def(STRUCT_SSTRING(cint_type));
  emit_typedef("STRUCT_SSTRING(cint8)","s8string_");
  emit_typedef("s8string_ *","S8string");
  emit_typedef("STRUCT_SSTRING(cint16)","s16string_");
  emit_typedef("s16string_ *","S16string");
  emit_typedef("STRUCT_SSTRING(cint32)","s32string_");
  emit_typedef("s32string_ *","S32string");
#endif
emit_typedef("struct { SSTRING_HEADER chart data[unspecified]; }","snstring_");
emit_typedef("snstring_*","Snstring");
export_def(sstring_length(ptr));
export_def(Sstring_length(obj));
export_def(sstring_eltype(ptr));









sprintf(buf,"struct { VRECORD_HEADER gcv_object_t data[unspecified]%s; }",attribute_aligned_object);
emit_typedef(buf,"svector_");
emit_typedef("svector_ *","Svector");
































































export_def(Atype_Bit);
export_def(Atype_8Bit);
export_def(Atype_32Bit);
export_def(Atype_T);










































































#ifdef TYPECODES
 export_def(Array_type_simple_bit_vector(atype));
#endif






























#if notused
sprintf(buf,"struct { XRECORD_HEADER gcv_object_t pack_external_symbols%s; gcv_object_t pack_internal_symbols%s; gcv_object_t pack_shadowing_symbols%s; gcv_object_t pack_use_list%s; gcv_object_t pack_used_by_list%s; gcv_object_t pack_name%s; gcv_object_t pack_nicknames%s; gcv_object_t pack_docstring%s; gcv_object_t pack_shortest_name%s; } *",attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object);
emit_typedef(buf,"Package");
#endif




































































































































































































































































sprintf(buf,"struct { XRECORD_HEADER gcv_object_t enc_eol%s; gcv_object_t enc_towcs_error%s; gcv_object_t enc_tombs_error%s;",attribute_aligned_object,attribute_aligned_object,attribute_aligned_object);
#ifdef UNICODE
  sprintf(buf+strlen(buf)," gcv_object_t enc_charset%s; gcv_object_t enc_mblen%s; gcv_object_t enc_mbstowcs%s; gcv_object_t enc_wcslen%s; gcv_object_t enc_wcstombs%s; gcv_object_t enc_range%s; gcv_object_t enc_table%s; uintL min_bytes_per_char; uintL max_bytes_per_char;",attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object,attribute_aligned_object);
#endif
strcat(buf," } *");
emit_typedef(buf,"Encoding");
#ifdef UNICODE
 export_def(Encoding_wcslen(encoding));
 export_def(Encoding_wcstombs(encoding));
#endif
export_def(cslen(encoding,src,srclen));
export_def(cstombs_help_(encoding,src,srclen,dest,destlen,A));
puts("#define cstombs(encoding,src,srclen,dest,destlen)  cstombs_help_(encoding,src,srclen,dest,destlen,ASSERT)");















#ifdef FOREIGN
  emit_typedef("struct { XRECORD_HEADER void* fp_pointer;} *","Fpointer");
  export_def(fp_validp(ptr));
  export_def(mark_fp_invalid(ptr));
#endif




























































































































































































































































































































































export_def(strm_buffered_bufflen);






emit_typedef("Srecord","Structure");
export_def(structure_types);































sprintf(buf,"struct { SRECORD_HEADER gcv_object_t inst_class_version%s; gcv_object_t other[unspecified]%s; } *",attribute_aligned_object,attribute_aligned_object);
emit_typedef(buf,"Instance");














































































































































































export_def(closure_flags(ptr));
export_def(closure_instancep(ptr));
export_def(Closure_instancep(obj));
























puts("typedef void Values;"); /* emit_typedef useless: no sizeof(void) */
emit_typedef_f("Values (*%s)()","lisp_function_t");












































































































sprintf(buf,"struct { XRECORD_HEADER gcv_object_t name%s; gcv_object_t keywords%s; lisp_function_t function; uintW argtype; uintW req_count; uintW opt_count; uintB rest_flag; uintB key_flag; uintW key_count; uintB seclass; uintB fastcmp; } %%s",attribute_aligned_object,attribute_aligned_object);
#if defined(HEAPCODES) && (alignment_long < 4) && defined(GNU)
  strcat(buf," __attribute__ ((aligned (4)))");
#endif
emit_typedef_f(buf,"subr_t");
emit_typedef("subr_t *","Subr");
emit_typedef("enum { subr_norest, subr_rest }","subr_rest_t");
emit_typedef("enum { subr_nokey, subr_key, subr_key_allow }","subr_key_t");
















puts("enum { seclass_foldable, seclass_no_se, seclass_read, seclass_write, seclass_default};");











































export_def(make_machine(ptr));
















































export_def(make_system(data));



export_def(unbound);








export_def(nullobj);
export_def(gcv_nullobj);











































#if defined(DEBUG_GCSAFETY)
  puts("static inline aint cgci_pointable (object obj) { return obj.one_o; }");
  puts("static inline aint cgci_pointable (gcv_object_t obj) { return obj.one_o; }");
  puts("static inline aint pgci_pointable (object obj) { if (!(gcinvariant_object_p(obj) || gcinvariant_symbol_p(obj) || obj.allocstamp == alloccount || nonimmsubrp(obj))) abort(); nonimmprobe(obj.one_o); return obj.one_o; }");
  puts("static inline aint pgci_pointable (gcv_object_t obj) { nonimmprobe(obj.one_o); return obj.one_o; }");
  puts("static inline aint ngci_pointable (object obj) { if (!(gcinvariant_symbol_p(obj) || obj.allocstamp == alloccount || nonimmsubrp(obj))) abort(); nonimmprobe(obj.one_o); return obj.one_o; }");
  puts("static inline aint ngci_pointable (gcv_object_t obj) { nonimmprobe(obj.one_o); return obj.one_o; }");
#else
  export_def(cgci_pointable(obj));
  export_def(pgci_pointable(obj));
  export_def(ngci_pointable(obj));
#endif
























































































































































































































































export_def(TheCons(obj));
#if notused
  export_def(TheRatio(obj));
  export_def(TheComplex(obj));
#endif
export_def(TheSymbol(obj));
export_def(TheBignum(obj));
#if notused
  export_def(TheSarray(obj));
#endif
export_def(TheSbvector(obj));
#ifdef HAVE_SMALL_SSTRING
  export_def(TheS8string(obj));
  export_def(TheS16string(obj));
  export_def(TheS32string(obj));
#endif
export_def(TheSstring(obj));
export_def(TheSvector(obj));
export_def(TheRecord(obj));
export_def(TheSrecord(obj));
#if notused
  export_def(TheXrecord(obj));
  export_def(ThePackage(obj));
#endif
export_def(TheEncoding(obj));
#ifdef FOREIGN
  export_def(TheFpointer(obj));
#endif
export_def(TheStructure(obj));
export_def(TheClosure(obj));
export_def(TheInstance(obj));
export_def(TheSubr(obj));
export_def(TheMachine(obj));
export_def(TheMachineCode(obj));
export_def(ThePseudofun(obj));






































export_def(Car(obj));
export_def(Cdr(obj));
export_def(Symbol_value(obj));
export_def(Symbol_function(obj));
export_def(Symbol_plist(obj));
export_def(Symbol_name(obj));
export_def(Symbol_package(obj));























export_def(eq(obj1,obj2));



export_def(nullp(obj));






export_def(boundp(obj));



export_def(missingp(obj));























export_def(consp(obj));
export_def(mconsp(obj));























export_def(atomp(obj));
export_def(matomp(obj));






export_def(listp(obj));





#ifndef TYPECODES
  export_def(varobjectp(obj));
#endif

















export_def(symbolp(obj));

















#if notused
#ifdef TYPECODES
 export_def(numberp(obj));
#else
 export_def(immediate_number_p(obj));
#endif
#endif












export_def(vectorp(obj));


































export_def(simple_vector_p(obj));












export_def(general_vector_p(obj));











export_def(simple_string_p(obj));











export_def(stringp(obj));

























export_def(simple_bit_vector_p(atype,obj));












export_def(bit_vector_p(atype,obj));













export_def(arrayp(obj));

















































































export_def(instancep(obj));































































export_def(orecordp(obj));

















export_def(structurep(obj));








export_def(builtin_stream_p(obj));








#if notused
export_def(packagep(obj));
#endif











































































#ifdef FOREIGN
  export_def(fpointerp(obj));
#endif












































export_def(charp(obj));




























#ifndef TYPECODES
  #ifdef LINUX_NOEXEC_HEAPCODES
    #ifdef DEBUG_GCSAFETY
      printf2("static inline bool nonimmsubrp (object obj) { return (varobjectp(obj) && (varobject_type((Record)(cgci_pointable(obj)-%d)) == %d)); }\n",varobject_bias,Rectype_Subr);
    #endif
  #endif
#endif





















































































export_def(integerp(obj));







export_def(fixnump(obj));







export_def(posfixnump(obj));








export_def(bignump(obj));










export_def(posbignump(obj));







#if notused
  export_def(ratiop(obj));
#endif













#if notused
  export_def(floatp(obj));
#endif







#if notused
  export_def(short_float_p(obj));
#endif







export_def(single_float_p(obj));







export_def(double_float_p(obj));







#if notused
  export_def(long_float_p(obj));
#endif







#if notused
  export_def(complexp(obj));
#endif















export_def(positivep(obj));



















































































































































































































































































































































































export_def(R_minusp(obj));















































export_def(FN_positivep(obj));







export_def(BN_positivep(obj));
















































































export_def(uint8_p(obj));
export_def(sint8_p(obj));
export_def(uint16_p(obj));
export_def(sint16_p(obj));
export_def(uint32_p(obj));
export_def(sint32_p(obj));
export_def(uint64_p(obj));
export_def(sint64_p(obj));
export_def(uint_p);
export_def(sint_p);
export_def(ulong_p);
export_def(slong_p);







export_def(UNIX_LISP_TIME_DIFF);




































































































































































#ifdef UNIX
  puts("extern object convert_time_to_universal (const time_t* time);");
#endif
#ifdef WIN32_NATIVE
  puts("extern object convert_time_to_universal (const FILETIME* time);");
#endif









#ifdef UNIX
  puts("extern void convert_time_from_universal (object universal, time_t* time);");
#endif
#ifdef WIN32_NATIVE
  puts("extern void convert_time_from_universal (object universal, FILETIME* time);");
#endif















































































































































































































































































#if (defined(GNU) || defined(INTEL)) && defined(I80386) && !defined(NO_ASM)
  printf("%s\n","#define SP()  ({aint __SP; __asm__ __volatile__ (\"movl %%esp,%0\" : \"=g\" (__SP) : ); __SP; })");
#endif

























#if !defined(STACK_register)
  puts("extern gcv_object_t* STACK;");
#else
  puts("#ifndef IN_MODULE_CC");
  printf("register gcv_object_t* STACK __asm__(\"%s\");\n",STACK_register);
  puts("#endif");
#endif

















puts("struct backtrace_t {\n  struct backtrace_t* bt_next;\n  gcv_object_t bt_function;\n  gcv_object_t *bt_stack;\n  int bt_num_arg;\n};");




























emit_typedef("struct backtrace_t *","p_backtrace_t");




















































































































#ifdef HAVE_SAVED_mv_count
  puts("extern uintC saved_mv_count;");
#endif
#ifdef HAVE_SAVED_value1
  puts("extern object saved_value1;");
#endif
#ifdef HAVE_SAVED_back_trace
  puts("extern p_backtrace_t saved_back_trace;");
#endif
#if defined(HAVE_SAVED_STACK)
  puts("extern gcv_object_t* saved_STACK;");
#endif
export_def(begin_call());
export_def(end_call());
export_def(begin_callback());
export_def(end_callback());





















































export_def(begin_system_call());
export_def(end_system_call());
























































#if notused
export_def(check_STACK());
export_def(STACK_overflow());
export_def(get_space_on_STACK(n));
puts("extern void* STACK_bound;");
puts("nonreturning_function(extern, STACK_ueber, (void));");
#endif

























puts("nonreturning_function(extern, error_notreached, (const char * file, uintL line));");







































#if !defined(LANGUAGE_STATIC) && defined(GNU_GETTEXT)
  puts("#define GNU_GETTEXT");
  puts("#ifndef COMPILE_STANDALONE");
  puts("#include <libintl.h>");
  puts("#endif");
  puts("extern const char * clgettext (const char * msgid);");
  export_def(GETTEXT);
#else
  export_def(GETTEXT(english));
#endif







#ifndef LANGUAGE_STATIC
  #ifndef GNU_GETTEXT
    emit_define("CLSTEXT","ascii_to_string");
  #else
    puts("extern object CLSTEXT (const char* asciz);");
  #endif
#endif

























puts("extern object object_out (object obj);");
puts("#define OBJECT_OUT(obj,label)  (printf(\"[%s:%d] %s: %s:\\n\",__FILE__,__LINE__,STRING(obj),label),obj=object_out(obj))");

































puts("extern object allocate_cons (void);");








#if notused
puts("extern object make_symbol (object string);");
#endif








puts("extern object allocate_vector (uintL len);");









puts("extern object allocate_bit_vector (uintB atype, uintL len);");





































































#if !defined(UNICODE)
  puts("extern object allocate_s8string (uintL len);");
#endif










































#ifdef UNICODE
  puts("extern object allocate_s32string (uintL len);");
#endif





















export_def(allocate_string(len));












































































































































































































































































































































































#ifdef FOREIGN
  puts("extern object allocate_fpointer (FOREIGN foreign);");
#endif





























































#if defined(FOREIGN_HANDLE)
  puts("extern object allocate_handle (Handle handle);");
#else
  export_def(allocate_handle(handle));
#endif























































































































#ifdef asciz_length
  export_def(asciz_length(a));
#else
  puts("extern uintL asciz_length (const char * asciz);");
#endif








#if notused
#ifdef asciz_length
  export_def(asciz_equal(a1,a2));
#else
  puts("extern bool asciz_equal (const char * asciz1, const char * asciz2);");
#endif
#endif




puts("extern void* my_malloc (size_t size);");




puts("extern void* my_realloc (void *ptr, size_t size);");



































































































































































































#if notused
emit_typedef_f("Values %s(void)","subr_norest_function_t");
emit_typedef_f("Values %s(uintC argcount, object* rest_args_pointer)","subr_rest_function_t");
#endif

















puts("extern struct subr_tab_ {");
puts("  VAROBJECTS_ALIGNMENT_DUMMY_DECL");
#undef LISPFUN
#define LISPFUN(name,sec,req_count,opt_count,rest_flag,key_flag,key_count,keywords) \
  printf("  subr_t %s;\n",STRING(D_##name));
#include "subr.c"
#undef LISPFUN
puts("} subr_tab_data;");

























#if defined(MAP_MEMORY_TABLES)
  export_def(subr_tab_addr);
#endif
export_def(subr_tab);
export_def(subr_tab_ptr_as_object(subr_addr));
export_def(L_help_(name));
emit_define("L(name)","L_help_(D_##name)");






puts("typedef const void *  Pseudofun;");








































puts("extern struct symbol_tab_ {");
puts("  VAROBJECTS_ALIGNMENT_DUMMY_DECL");
#define LISPSYM(name,printname,package)  \
  printf("  symbol_ %s;\n",STRING(S_##name));
#include "constsym.c"
#undef LISPSYM
puts("} symbol_tab_data;");






























emit_define("S(name)","S_help_(S_##name)");
#if defined(MAP_MEMORY_TABLES)
  export_def(symbol_tab_addr);
#endif
export_def(symbol_tab);
export_def(S_help_(name));



export_def(NIL);
export_def(T);































#if defined(DEBUG_GCSAFETY)
  printf("static inline bool gcinvariant_symbol_p (object obj) { if (");
  #ifdef TYPECODES
    printf("symbolp(obj)");
  #else
    printf("varobjectp(obj)");
  #endif
  printf(" && (");
  #if !defined(MAP_MEMORY_TABLES)
    #ifdef TYPECODES
      printf2("(as_oint(obj) >> %d) - %d", oint_addr_shift-addr_shift, (aint)(tint)symbol_type<<oint_type_shift);
    #else
      printf1("as_oint(obj) - %d", varobject_bias);
    #endif
  #else
    printf("as_oint(obj)");
  #endif
  puts(" - (aint)&symbol_tab < sizeof(symbol_tab))) return true; else return false; }");
#endif

















puts("extern struct object_tab_ {");
#define LISPOBJ(name,init)  printf("  gcv_object_t %s;\n",STRING(name));
#include "constobj.c"
#undef LISPOBJ
puts("} object_tab;");



/* FIXME: Difference between lispbibl.d and clisp.h */
puts("#define GLO(name)  (object_tab.name)");






export_def(PROT_READ);
export_def(PROT_READ_WRITE);
#if defined(GENERATIONAL_GC) && defined(SPVW_MIXED)
puts("extern bool handle_fault_range (int prot, aint start_address, aint end_address);");
#else
puts("#define handle_fault_range(p,s,e)");
#endif













puts("extern uintC module_count;");






emit_typedef("struct { const char* packname; const char* symname; }","subr_initdata_t");





emit_typedef("struct { const char* initstring; }","object_initdata_t");


























strcpy(buf,"struct module_t { const char* name; subr_t* stab; const uintC* stab_size; gcv_object_t* otab; const uintC* otab_size; bool initialized; const subr_initdata_t* stab_initdata; const object_initdata_t* otab_initdata; void (*initfunction1) (struct module_t *); void (*initfunction2) (struct module_t *); void (*finifunction) (struct module_t *);");
#ifdef DYNAMIC_MODULES
  strcat(buf," struct module_t * next;");
#endif
strcat(buf," }"); emit_typedef(buf,"module_t");
#ifdef DYNAMIC_MODULES
  puts("BEGIN_DECLS");
  puts("extern void add_module (module_t * new_module);");
  puts("END_DECLS");
#else
  puts("extern module_t modules[];");
#endif






































































































































































































































































































































































































































































































































































































export_def(STACK_(n));
export_def(skipSTACKop);
export_def(STACKop);
export_def(pushSTACK(obj));
export_def(popSTACK());
export_def(skipSTACK(n));













{ int i;
  for (i=0; i<=10; i++)
    printf("#define STACK_%d  (STACK_(%d))\n",i,i);
}























































#if notused
export_def(mv_limit);
#endif
#if !defined(mv_count_register)
  puts("extern uintC mv_count;");
#else
  puts("#ifndef IN_MODULE_CC");
  printf("register uintC mv_count __asm__(\"%s\");\n",mv_count_register);
  puts("#endif");
#endif
printf("extern object mv_space [%d];\n",mv_limit-1);
#if !defined(value1_register)
  emit_define("value1","mv_space[0]");
#else
  puts("#ifndef IN_MODULE_CC");
  printf("register object value1 __asm__(\"%s\");\n",value1_register);
  puts("#endif");
#endif
{ int i = 2;
  for (; i <=9 ; i++)
    printf("#define value%d  mv_space[%d]\n",i,i-1);
}








































export_def(STACK_to_mv(countx));






























































































#if notused
puts("nonreturning_function(extern, error_mv_toomany, (object caller));");
#endif







#if !defined(back_trace_register)
  puts("extern p_backtrace_t back_trace;");
#else
  puts("#ifndef IN_MODULE_CC");
  printf("register p_backtrace_t back_trace __asm__(\"%s\");\n",back_trace_register);
  puts("#endif");
#endif
export_def(subr_self);
















































emit_define("args_end_pointer","STACK");
#if notused
emit_define("set_args_end_pointer(new_args_end_pointer)","STACK = (new_args_end_pointer)");
export_def(NEXT(argpointer));
export_def(BEFORE(argpointer));
emit_define("Next(pointer)","(*(STACKpointable(pointer) STACKop -1))");
emit_define("Before(pointer)","(*(STACKpointable(pointer) STACKop 0))");
#endif



































































































































































































































































#ifdef HAVE_SAVED_REGISTERS
  export_def(CALLBACK_frame_info);
#endif



















































































































#ifdef HEAPCODES
 export_def(makebottomword(type,size));
#endif
export_def(framecode(bottomword));










































export_def(framebottomword(type,top_of_frame,bot_of_frame));
export_def(finish_frame(frametype));



















































































#if notused
puts("extern Values apply (object fun, uintC args_on_stack, object other_args);");
#endif










puts("extern Values funcall (object fun, uintC argcount);");








#if notused
puts("extern Values eval (object form);");
#endif


















































































































































































































































































































































































































































































#ifdef UNICODE
  puts("extern object n_char_to_string (const char* charptr, uintL len, object encoding);");
#else
  emit_define("n_char_to_string(charptr,len,encoding)","n_char_to_string_(charptr,len)");
  puts("extern object n_char_to_string_ (const char* charptr, uintL len);");
#endif

















#ifdef UNICODE
  puts("extern object asciz_to_string (const char * asciz, object encoding);");
#else
  emit_define("asciz_to_string(asciz,encoding)","asciz_to_string_(asciz)");
  puts("extern object asciz_to_string_ (const char * asciz);");
#endif
puts("extern object ascii_to_string (const char * asciz);");

















#ifdef UNICODE
  puts("extern object string_to_asciz (object obj, object encoding);");
#else
  export_def(string_to_asciz(obj,encoding));
  puts("extern object string_to_asciz_ (object obj);");
#endif
export_def(TheAsciz(obj));
















































export_def(with_string_0_help_(string,encoding,ascizvar,statement,ascizvar_len,ascizvar_offset,ascizvar_string,ascizvar_bytelen,ascizvar_data,A,NR));
export_def(with_sstring_0_help_(string,encoding,ascizvar,statement,ascizvar_len,ascizvar_string,ascizvar_bytelen,ascizvar_data,A,NR));
/* cannot use emit_define because Rectype_* is not a define in lispbibl.d */
puts("#define with_string_0(string,encoding,ascizvar,statement) with_string_0_help_(string,encoding,ascizvar,statement,ascizvar##_len,ascizvar##_offset,ascizvar##_string,ascizvar##_bytelen,ascizvar##_data,ASSERT,NOTREACHED)");
puts("#define with_sstring_0(string,encoding,ascizvar,statement) with_sstring_0_help_(string,encoding,ascizvar,statement,ascizvar##_len,ascizvar##_string,ascizvar##_bytelen,ascizvar##_data,ASSERT,NOTREACHED)");






















































































































puts("extern uintL vector_length (object vector);");






















puts("extern object vectorof (uintC len);");




















puts("extern object array_displace_check (object array, uintV size, uintL* index);");




export_def(simple_nilarray_p(obj));










puts("nonreturning_function(extern, error_nilarray_retrieve, (void));");

























































puts("extern uintBWL array_atype (object array);");















puts("extern uintL array_rank (object array);");









puts("extern void get_array_dimensions (object array, uintL rank, uintL* dimensions);");





















































































































#if notused
puts("extern object allocate_bit_vector_0 (uintL len);");
#endif




























































































#if notused
puts("extern chart up_case (chart ch);");
#endif





#if notused
puts("extern chart down_case (chart ch);");
#endif







































#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_8bit_16bit (const uint8* src, uint16* dest, uintL len);");
#endif









#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_8bit_32bit (const uint8* src, uint32* dest, uintL len);");
#endif










#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_16bit_8bit (const uint16* src, uint8* dest, uintL len);");
#endif









#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_16bit_16bit (const uint16* src, uint16* dest, uintL len);");
#endif









#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_16bit_32bit (const uint16* src, uint32* dest, uintL len);");
#endif










#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_32bit_8bit (const uint32* src, uint8* dest, uintL len);");
#endif










#ifdef HAVE_SMALL_SSTRING
  puts("extern void copy_32bit_16bit (const uint32* src, uint16* dest, uintL len);");
#endif
















































































































































export_def(unpack_sstring_alloca_help_(string,len,offset,charptr_assignment,u));
puts("#define unpack_sstring_alloca(s,l,o,c) unpack_sstring_alloca_help_(s,l,o,c,NOTREACHED)");
























puts("extern object unpack_string_ro (object string, uintL* len, uintL* offset);");
















puts("extern bool string_equal (object string1, object string2);");



























































































































































puts("typedef struct stringarg { object string; uintL offset; uintL index; uintL len; } stringarg;");
















puts("extern void test_vector_limits (stringarg* arg);");




























































































puts("extern object string_concat (uintC argcount);");



























puts("extern object gethash (object obj, object ht, bool allowgc);");









































































































































































































puts("extern object copy_list (object old_list);");



















puts("extern uintL llength1 (object obj, object* last);");









#if notused
puts("extern object make_list (uintL len);");
#endif







puts("extern object nreverse (object list);");

















puts("extern object deleteq (object list, object obj);");









puts("extern bool endp (object obj);");


























puts("extern object listof (uintC len);");




puts("extern object memq (const object obj, const object lis);");

























emit_typedef("struct { long c_const; gcv_object_t *l_const; }","c_lisp_pair_t");
emit_typedef("struct { const c_lisp_pair_t *table; const unsigned int size; const long default_value; const bool have_default_value_p;  const bool use_default_function_p; const char *name; }","c_lisp_map_t");
puts("extern long map_lisp_to_c (object obj, const c_lisp_map_t *map);");
puts("extern object map_c_to_lisp (long val, const c_lisp_map_t *map);");
puts("extern object map_c_to_list (long val, const c_lisp_map_t *map);");
puts("extern long map_list_to_c (object obj, const c_lisp_map_t *map);");

puts("extern void push_string_array (char **arr);");

puts("extern object safe_to_string (const char *asciz);");









































printf("typedef enum { condition=%d, serious_condition=%d, error_condition=%d, program_error=%d, source_program_error=%d, control_error=%d, arithmetic_error=%d, division_by_zero=%d, floating_point_overflow=%d, floating_point_underflow=%d, cell_error=%d, unbound_variable=%d, undefined_function=%d, unbound_slot=%d, type_error=%d, keyword_error=%d, charset_type_error=%d, package_error=%d, print_not_readable=%d, parse_error=%d, stream_error=%d, end_of_file=%d, reader_error=%d, file_error=%d, os_error=%d, storage_condition=%d, interrupt_condition=%d, warning=%d } condition_t;\n",condition, serious_condition, error_condition, program_error, source_program_error, control_error, arithmetic_error, division_by_zero, floating_point_overflow, floating_point_underflow, cell_error, unbound_variable, undefined_function, unbound_slot, type_error, keyword_error, charset_type_error, package_error, print_not_readable, parse_error, stream_error, end_of_file, reader_error, file_error, os_error, storage_condition, interrupt_condition, warning);










puts("nonreturning_function(extern, error, (condition_t errortype, const char * errorstring));");
















puts("extern void check_value (condition_t errortype, const char * errorstring);");





























puts("nonreturning_function(extern, OS_file_error, (object pathname));");











puts("nonreturning_function(extern, OS_filestream_error, (object stream));");


























puts("extern object check_classname (object obj, object classname);");

















#ifdef FOREIGN
  puts("extern object check_fpointer_replacement (object obj, bool restart_p);");
  puts("#ifndef COMPILE_STANDALONE");
  puts("static inline object check_fpointer (object obj, bool restart_p) {"
         " if (!(fpointerp(obj) && fp_validp(TheFpointer(obj))))"
           " obj = check_fpointer_replacement(obj,restart_p);"
         " return obj;"
       " }");
  puts("#endif");
#endif






#if notused
puts("nonreturning_function(extern, error_list, (object obj));");
#endif





















puts("extern object check_list_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(list));
puts("#endif");







puts("nonreturning_function(extern, error_proper_list_dotted, (object caller, object obj));");





























































#if notused
puts("nonreturning_function(extern, error_no_svector, (object caller, object obj));");
#endif






#if notused
puts("nonreturning_function(extern, error_vector, (object obj));");
#endif










puts("extern object check_array_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(array));
puts("#endif");










puts("extern object check_vector_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(vector));
puts("#endif");










puts("extern object check_byte_vector_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_LOW(byte_vector,bit_vector_p(Atype_8Bit,obj)));
puts("#endif");






















puts("extern object check_posfixnum_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(posfixnum));
puts("#endif");




















puts("extern object check_pos_integer_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_LOW(pos_integer,(integerp(obj)&&!R_minusp(obj))));
puts("#endif");
















#if notused
puts("extern object check_char_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(char));
puts("#endif");
#endif










puts("extern object check_string_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK(string));
puts("#endif");






#if notused
puts("nonreturning_function(extern, error_sstring, (object obj));");
#endif















puts("nonreturning_function(extern, error_string_integer, (object obj));");































puts("nonreturning_function(extern, error_plist_odd, (object plist));");






puts("nonreturning_function(extern, error_key_odd, (uintC argcount, object caller));");















puts("nonreturning_function(extern, error_key_badkw, (object fun, object key, object val, object kwlist));");

























































































export_def(error_uint8(obj));
export_def(error_sint8(obj));
export_def(error_uint16(obj));
export_def(error_sint16(obj));
export_def(error_uint32(obj));
export_def(error_sint32(obj));
export_def(error_uint64(obj));
export_def(error_sint64(obj));
#if (int_bitsize==16)
  emit_define("error_uint","error_uint16");
  emit_define("error_sint","error_sint16");
#else
  emit_define("error_uint","error_uint32");
  emit_define("error_sint","error_sint32");
#endif
#if (long_bitsize==32)
  emit_define("error_ulong","error_uint32");
  emit_define("error_slong","error_sint32");
#else
  emit_define("error_ulong","error_uint64");
  emit_define("error_slong","error_sint64");
#endif

































































puts("extern object check_c_integer_replacement (object obj, int tcode, bool signedp);");
export_def(check_uint8_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(uint8));
puts("#endif");
export_def(check_sint8_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(sint8));
puts("#endif");
export_def(check_uint16_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(uint16));
puts("#endif");
export_def(check_sint16_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(sint16));
puts("#endif");
export_def(check_uint32_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(uint32));
puts("#endif");
export_def(check_sint32_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(sint32));
puts("#endif");
export_def(check_uint64_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(uint64));
puts("#endif");
export_def(check_sint64_replacement(obj));
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(sint64));
puts("#endif");
puts("extern object check_uint_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(uint));
puts("#endif");
puts("extern object check_sint_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(sint));
puts("#endif");
puts("extern object check_ulong_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(ulong));
puts("#endif");
puts("extern object check_slong_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_(slong));
puts("#endif");
puts("extern object check_ffloat_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_LOW(ffloat,single_float_p(obj)));
puts("#endif");
puts("extern object check_dfloat_replacement (object obj);");
puts("#ifndef COMPILE_STANDALONE");
export_literal(MAKE_CHECK_LOW(dfloat,double_float_p(obj)));
puts("#endif");






































puts("extern object find_package (object string);");














puts("extern uintBWL intern (object string, object pack, object* sym_);");








puts("extern object intern_keyword (object string);");





















































puts("extern object physical_namestring (object obj);");








puts("extern object pathname_to_OSdir (object pathname, bool use_default);");







puts("extern object OSdir_to_pathname (const char* path);");












puts("extern Handle handle_dup (Handle old_handle);");







puts("extern Handle handle_dup2 (Handle old_handle, Handle new_handle);");




















printf("typedef enum { DIRECTION_PROBE=%d, DIRECTION_INPUT=%d, DIRECTION_INPUT_IMMUTABLE=%d, DIRECTION_OUTPUT=%d, DIRECTION_IO=%d} direction_t;\n",
       DIRECTION_PROBE, DIRECTION_INPUT, DIRECTION_INPUT_IMMUTABLE,
       DIRECTION_OUTPUT, DIRECTION_IO);
puts("extern direction_t check_direction (object dir);");











emit_typedef("enum { IF_DOES_NOT_EXIST_UNBOUND, IF_DOES_NOT_EXIST_ERROR, IF_DOES_NOT_EXIST_NIL, IF_DOES_NOT_EXIST_CREATE }","if_does_not_exist_t");
puts("extern if_does_not_exist_t check_if_does_not_exist (object if_not_exist);");




puts("extern object if_does_not_exist_symbol (if_does_not_exist_t if_not_exist);");















emit_typedef("enum { IF_EXISTS_UNBOUND, IF_EXISTS_ERROR, IF_EXISTS_NIL, IF_EXISTS_RENAME, IF_EXISTS_RENAME_AND_DELETE, IF_EXISTS_SUPERSEDE, IF_EXISTS_APPEND, IF_EXISTS_OVERWRITE }","if_exists_t");
puts("extern if_exists_t check_if_exists (object if_exists);");




puts("extern object if_exists_symbol (if_exists_t if_exists);");































#if notused
puts("extern bool eql (object obj1, object obj2);");
#endif







#if notused
puts("extern bool equal (object obj1, object obj2);");
#endif







#if notused
puts("extern bool equalp (object obj1, object obj2);");
#endif







puts("extern bool typep_class (object obj, object clazz);");







puts("extern bool typep_classname (object obj, object classname);");

















































































































puts("typedef void map_sequence_function_t (void* arg, object element);");
puts("extern void map_sequence (object obj, map_sequence_function_t* fun, void* arg);");























puts("extern struct timeval * sec_usec (object sec, object usec, struct timeval *tv);");









#if defined(SIZEOF_STRUCT_TIMEVAL) && SIZEOF_STRUCT_TIMEVAL == 16
puts("extern object sec_usec_number (uint64 sec, uint64 usec, bool abs_p);");
#else
puts("extern object sec_usec_number (uint32 sec, uint32 usec, bool abs_p);");
#endif





























































































































puts("extern void builtin_stream_close (const gcv_object_t* stream_, uintB abort);");

















































































































puts("extern Handle stream_lend_handle (gcv_object_t *stream_, bool inputp, int * handletype);");








puts("extern object open_file_stream_handle (object stream, Handle *fd);");








puts("extern off_t handle_length (object stream, Handle fd);");












puts("extern uintL read_byte_array (const gcv_object_t* stream_, const gcv_object_t* bytearray_, uintL start, uintL len, perseverance_t persev);");












puts("extern uintL write_byte_array (const gcv_object_t* stream_, const gcv_object_t* bytearray_, uintL start, uintL len, perseverance_t persev);");



































puts("extern object file_stream_truename (object s);");


























puts("extern object make_file_stream (direction_t direction, bool append_flag,bool handle_fresh);/*+6 arguments on the STACK!*/");




puts("extern void stream_handles (object obj, bool check_open, bool* char_p, SOCKET* in_sock, SOCKET* out_sock);");
































































































































#if defined(UNIX) || defined(WIN32_NATIVE)
  puts("extern object addr_to_string (short type, char *addr);");
#endif















#if (defined(UNIX) || defined(WIN32_NATIVE)) && defined(HAVE_GETHOSTBYNAME) && defined(TCPCONN)
  puts("extern object string_to_addr (const char *name);");
#endif













#if (defined(UNIX) || defined(WIN32_NATIVE)) && defined(HAVE_GETHOSTBYNAME) && defined(TCPCONN)
  puts("extern struct hostent* resolve_host (object arg);");
#endif



































































#if notused
puts("extern object get (object symbol, object key);");
#endif





























puts("extern object L_to_I (sint32 val);");


















#if (intLsize<=oint_data_len)
  export_def(UL_to_I(val));
#else
  puts("extern object UL_to_I (uintL val);");
#endif













#if (intVsize>32)
  export_def(L2_to_I(val_hi,val_lo));
#else
  puts("extern object L2_to_I (sint32 val_hi, uint32 val_lo);");
#endif













#if (intVsize>32)
  export_def(UL2_to_I(val_hi,val_lo));
#else
  puts("extern object UL2_to_I (uint32 val_hi, uint32 val_lo);");
#endif










#if defined(intQsize) || (intVsize>32)
  puts("extern object Q_to_I (sint64 val);");
#endif










#if defined(intQsize) || (intVsize>32)
  puts("extern object UQ_to_I (uint64 val);");
#endif













#if notused
#if (intVsize<=32)
  emit_define("V_to_I(val)","L_to_I(val)");
#else
  emit_define("V_to_I(val)","Q_to_I(val)");
#endif
#endif













#if notused
#if (intVsize<=32)
  emit_define("UV_to_I(val)","UL_to_I(val)");
#else
  emit_define("UV_to_I(val)","UQ_to_I(val)");
#endif
#endif































export_def(uint8_to_I(val));
export_def(sint8_to_I(val));
export_def(uint16_to_I(val));
export_def(sint16_to_I(val));
export_def(uint32_to_I(val));
export_def(sint32_to_I(val));
export_def(uint64_to_I(val));
export_def(sint64_to_I(val));
export_def(uint_to_I(val));
export_def(sint_to_I(val));
export_def(ulong_to_I(val));
export_def(slong_to_I(val));






























puts("extern uintL I_to_UL (object obj);");







puts("extern sintL I_to_L (object obj);");









#ifdef HAVE_LONG_LONG_INT
  puts("extern uint64 I_to_UQ (object obj);");
#endif









#ifdef HAVE_LONG_LONG_INT
  puts("extern sint64 I_to_Q (object obj);");
#endif






































export_def(I_to_uint8(obj));
export_def(I_to_sint8(obj));
export_def(I_to_uint16(obj));
export_def(I_to_sint16(obj));
export_def(I_to_uint32(obj));
export_def(I_to_sint32(obj));
export_def(I_to_uint64(obj));
export_def(I_to_sint64(obj));
export_def(I_to_uint);
export_def(I_to_sint);
export_def(I_to_ulong);
export_def(I_to_slong);









puts("extern object UDS_to_I (uintD* MSDptr, uintC len);");








puts("extern object DS_to_I (const uintD* MSDptr, uintC len);");











#if notused
puts("extern object I_1_plus_I (object x);");
#endif






#if notused
puts("extern object I_minus1_plus_I (object x);");
#endif






#if notused
puts("extern object I_I_plus_I (object x, object y);");
#endif






#if notused
puts("extern object I_I_minus_I (object x, object y);");
#endif











puts("extern uintL I_integer_length (object x);");








puts("extern object LEbytes_to_UI (uintL bytesize, const uintB* bufferptr);");


















puts("extern object LEbytes_to_I (uintL bytesize, const uintB* bufferptr);");




















puts("extern bool UI_to_LEbytes (object obj, uintL bitsize, uintB* bufferptr);");









puts("extern bool I_to_LEbytes (object obj, uintL bitsize, uintB* bufferptr);");




puts("extern object c_float_to_FF (const ffloatjanus* val_);");




puts("extern void FF_to_c_float (object obj, ffloatjanus* val_);");




puts("extern object c_double_to_DF (const dfloatjanus* val_);");




puts("extern void DF_to_c_double (object obj, dfloatjanus* val_);");













































































































puts("extern double to_double (object obj);");







puts("extern int to_int (object obj);");












#ifdef DYNAMIC_FFI
 puts("#define HAVE_FFI");



























  puts("extern void register_foreign_variable (void* address, const char * name, uintBWL flags, uintL size);");



























  puts("extern void register_foreign_function (void* address, const char * name, uintWL flags);");








  puts("extern void register_foreign_inttype (const char * name_asciz, uintL size, bool signed_p);");




puts("extern object convert_from_foreign (object fvd, const void* data);");




puts("typedef void* converter_malloc_t (void* old_data, uintL size, uintL alignment);");
puts("extern converter_malloc_t mallocing, nomalloc;");





puts("extern void convert_to_foreign (object fvd, object obj, void* data, converter_malloc_t *converter_malloc);");










#endif








































































































































